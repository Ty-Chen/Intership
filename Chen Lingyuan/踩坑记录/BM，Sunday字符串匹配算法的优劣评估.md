#                                                             BM，Sunday字符串匹配算法的优劣评估



## BM算法

BM算法是现在广泛运用的字符串匹配算法，它具有非常高效的性能，文本编辑器的查找功能以及Linux下的grep命令都是基于BM算法。

与以往的字符串匹配算法不同，BM算法引进了"坏字符"与"好后缀"这一概念来获取模式串每次最大的跳跃距离。算法的具体规则在这里就不展开了。这里主要讲述算法的优劣情况。

因为模式串的跳跃距离是由"好后缀"与"坏字符"这两者的最大值决定的，所以模式串的长度，模式串本身的属性以及文本串的属性共同决定了BM算法的执行效率。

首先是匹配效率最快的情况:

```
  int buffersize = 1024 * 1024 * 1024;
    char *a = NULL;
    a = new char[buffersize];
    for (int i = 0; i < buffersize; i++)
    {
        a[i] = 'a';
    }
    char b[] = "bcdefg";
    start = clock();
    str_bm(a, buffersize, b, strlen(b));
    end = clock();
    printf("%d\n", end - start);
```

我自定义了大小为1GB的文本串，每个字符填充'a',然后又定义了一个长度为6的模式，可以看出来模式串中的每个字符都与文本串中不匹配，并且模式串中也没有"好后缀"的情况，在这种情况下一旦最后一位字符没有匹配，模式串的移动距离就是模式串的长度，整个算法的时间复杂度就是最快的亚线性O(n/m)。这种情况虽然比较极端，但是在平时查找的字符串时与这种情况有比较高的相似度，而且一般来说模式串越长，算法的优势越明显，这就是为什么广泛使用BM算法的原因。

但是这种情况也有一个缺陷，那就是在模式串长度变小之后，算法的效率会急剧退化，我将模式串的长度变为1，并开始测试;

```
int buffersize = 1024 * 1024 * 1024;
    char *a = NULL;
    a = new char[buffersize];
    for (int i = 0; i < buffersize; i++)
    {
        a[i] = 'a';
    }
    char b[] = "b";
    int sum = 0;

    start = clock();
    for (int i = 0; i < buffersize; i++)
    {
        if (a[i] == 'b')
        {
            sum++;
        }
    }
   // str_bm(a, buffersize, b, strlen(b));
    end = clock();
    printf("%d\n", end - start);
```

首先是直接遍历文本串判断，时间为大约为2000ms，然后使用BM算法进行匹配，时间大约为4800ms，可以看到效率差距非常大，主要的原因是无论是暴力匹配还是BM算法，模式串的跳跃距离每次都是1，但是BM算法每次都要对"坏字符"以及"好后缀"大小进行判断，这个步骤非常消耗时间，这就是BM算法在短字符下效率低的原因。

还有一种情况效率也比较低，当模式串为“baaaaa”或"aaaaab"时，在第一种情况下，因为模式串是从末尾开始匹配，所以在匹配时会一直匹配到'b'为止，会浪费比较多的时间。第二种情况下，虽然一开始就能判断出是否匹配，但是每次跳跃的步距都1，算法效率大概与单字符旗鼓相当。但是这两种情况一般来说很少会碰到。

  总结：BM算法因为其算法特性，在一般模式串，一般文本串中有着比KMP算法更高的效率，所以这个算法使用更加广泛，但是传统BM算法因为每次要判断跳跃步距，所以在短字符处理方面差强人意，效率远低于KMP算法。

## Sunday算法

Sunday算法的出现BM算法来的要晚，据说也是现在最快的字符串匹配算法

Sunday算法的核心思想与BM算法的“坏字符”思想非常相似，都是匹配到一处不匹配之后，根据坏字符来决定跳跃的步距，不同的是BM算法是从后往前开始匹配字符串，而Sunday算法是从前往后开始匹配字符串。

​       为什么单单使用"坏字符"来匹配，因为我们平时查找的模式串在文本串跳转时用到“坏字符”的次数更多(毕竟没什么人会刻意去搜索“aaaaab”与"baaaaa"这种字符串)，这种时候Sunday算法的优势就体现出来了，因为没有了对“好后缀”以及“坏字符”的判断，再加上Sunday算法有着比BM算法“坏字符”更大的跳跃距离，所以在匹配短字符时效率大大提升，写了个测试来验证结果。

```
  int buffersize = 1024 * 1024 * 1024;
    unsigned char *a = NULL;
    a = new unsigned char[buffersize];
    for (int i = 0; i < buffersize; i++)
    {
        a[i] = 'a';
    }
    unsigned char b[] = "a";
    int sum = 0;

    start = clock();
    GetBadChar(b, strlen((char*)b), m_nBadChar,300);
    SundayCount(a, buffersize, b, strlen((char*)b));
    end = clock();
    printf("%d\n", end - start);
```

匹配时间大约为2400ms，比起BM算法的短字符匹配效率大幅提升，有效解决了BM算法在短字符情况下效率低的问题，同时在长字符串情况下有着不输于BM算法的效率，但是对于某些字符串，Sunday算法还是会存在与BM算法相似的问题，比如说在模式串为"baaaaa"或"aaaaab"的情况下，算法的效率会与BM算法一样急剧退化，在第一种情况下，虽然模式串一开始就不匹配，但受限于算法的特性，每次跳跃的步距仅为1（比单字符的跳跃距离还要少1），所以效率很低。第二种情况是最为严重的情况，这种情况下,模式串要匹配m次，但是每次移动的步距仅为1，算法的复杂度已经退化成了O(n*m),与暴力匹配 已经没什么差别了。

总结：Sunday算法在一般情况下有着比BM算法更大的跳跃距离，但是与BM算法一样会受限于某些情况，所以无论使用什么算法都要考虑实际情况，评估算法优劣之后再去使用。

