# 动态库与静态库

## 1.简介

在测试时，想要调用另一个项目里的代码，想到了使用静态库进行链接。

## 2.问题分析

### 	2.1.什么是库？

​		库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。
​		库有两种类型：静态库(.lib)和动态库(`.dll`)。
​		在一个程序编译成可执行程序的步骤：预编译→编译→汇编→链接;而在链接阶段，如何处理库，链接成可执行程序的方式有静态链接方式和动态链接方式。这也就是静态库与动态库的区别。

![](.\动态库与静态库学习.assets\image-20210105192941394.png)

### 	2.2.静态库

​		之所以成为静态库，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。对应的链接方式称为静态链接。

![](.\动态库与静态库学习.assets\image-20210105193058658.png)

#### 静态库特点

​			1.静态库对函数库的链接是在编译时期完成的。
​			2.程序在运行时与函数库再无瓜葛，移植方便。
​			3.浪费空间和资源。

### 	2.3.动态库

#### 		为什么需要动态库？

​			1.静态库浪费空间。
​			2.静态库对程序的更新、部署和发布页会带来麻烦.如果静态库更新，所有使用它的应用程序就都需要重新编译(用户需要重新下载整个程序，全量更新)。
​			3.动态库是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。因为动态库是在程序运行时才被载入，所以当动态库更新时，用户只需要更新动态库(增量更新)。
​		

![image-20210105193123833](.\动态库与静态库学习.assets\image-20210105193123833.png)

#### 	动态库特点

​		1.动态库把对一些库函数的链接载入推迟到程序运行的时期。
​		2.可以实现进程之间的资源共享(因此动态库也称为共享库)。
​		3.程序升级变得简单。
​		4.显式调用。	

### 2.4区别

静态库被使用目标代码最终和可执行文件在一起（它只会有自己用到的），而动态库与它相反，它的目标代码在运行时或者加载时链接。正是由于这个区别，会导致下面所介绍的这些区别。

##### 可执行文件大小不一样

静态链接的可执行文件要比动态链接的可执行文件要大得多，因为它将需要用到的代码从二进制文件中“拷贝”了一份，而动态库仅仅是复制了一些重定位和符号表信息。

##### 占用磁盘大小不一样

如果有多个可执行文件，那么静态库中的同一个函数的代码就会被复制多份，而动态库只有一份，因此使用静态库占用的磁盘空间相对比动态库要大。

##### 扩展性与兼容性不一样

如果静态库中某个函数的实现变了，那么可执行文件必须重新编译，而对于动态链接生成的可执行文件，只需要更新动态库本身即可，不需要重新编译可执行文件。正因如此，使用动态库的程序方便更新。

##### 依赖不一样

静态链接的可执行文件不需要依赖其他的内容即可运行，而动态链接的可执行文件必须依赖动态库的存在。所以如果你在安装一些软件的时候，提示某个动态库不存在的时候也就不奇怪了。

##### 复杂性不一样

相对来讲，动态库的处理要比静态库要复杂，例如，如何在运行时确定地址？多个进程如何共享一个动态库？当然，作为调用者我们不需要关注。另外动态库版本的管理也是一项技术活，下次在分析。

##### 加载速度不一样

由于静态库在链接时就和可执行文件在一块了，而动态库在加载或者运行时才链接，因此，对于同样的程序，静态链接的要比动态链接加载更快。所以选择静态库还是动态库是空间和时间的考量。但是通常来说，牺牲这点性能来换取程序在空间上的节省和部署的灵活性时值得的。再加上**局部性原理**，牺牲的性能并不多。

## 3.问题解决

采用了动态库后，方便了更新。之后又发现可以直接system去运行`exe`，来进行测试。

## 4.问题总结

仅简单介绍了一些静态库和动态库的区别，而静态库和动态库具体是何如链接的等方面问题以后去探究。