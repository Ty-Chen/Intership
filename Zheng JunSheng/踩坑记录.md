踩坑记录

1.fgets()函数
	char* fgets(
		char* const string, 
		int   const count, 
		FILE* const stream
	)；
实际上fgets只会读取count-1个字符，最后添加一个'\0'。
fgets()是
	1.判断是不是读到EOF，如果是退出循环。
	2.赋值。
	3.判断读到的是不是'\n'，如果是退出循环。
	4.退出循环之后，再赋值一个'\0'。

2.动态库与静态库
	2.1什么是库？
		库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。
		库有两种类型：静态库(.lib)和动态库(.dll)。
		在一个程序编译成可执行程序的步骤：预编译→编译→汇编→链接;而在链接阶段，如何处理库，链接成可执行程序的方式有静态链接方式和动态链接方式。这也就是静态库与动态库的区别。
	2.2静态库
		之所以成为静态库，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。对应的链接方式称为静态链接。
		静态库特点：
			1.静态库对函数库的链接是在编译时期完成的。
			2.程序在运行时与函数库再无瓜葛，移植方便。
			3.浪费空间和资源。
	2.3动态库
		为什么需要动态库？
			1.静态库浪费空间。
			2.静态库对程序的更新、部署和发布页会带来麻烦.如果静态库更新，所有使用它的应用程序就都需要重新编译(用户需要重新下载整个程序，全量更新)。
			3.
		动态库是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。因为动态库是在程序运行时才被载入，所以当动态库更新时，用户只需要更新动态库(增量更新)。
		
		动态库特点：
			1.动态库把对一些库函数的链接载入推迟到程序运行的时期。
			2.可以实现进程之间的资源共享(因此动态库也称为共享库)。
			3.程序升级变得简单。
			4.显式调用。		
3.char*与unsigned char*
	在Sunday中使用char*时，发现数据跑出来不对，通过单步调试发现，跳步的大小会出错，当pszText[nTextpos + m_nKeyLen] < 0时，m_nSunday[pszText[nTextPos + m_nKeyLen]]也就会出错。
	通过将char*改成unsigned char*后解决这个问题。char能表示的数据范围是-128~127，而unsigned char表示的范围是0~255.
	
	
	